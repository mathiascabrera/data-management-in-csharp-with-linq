----------    Welcome to the course    ----------

We will analyze each of the operators and clauses that LINQ has for manipulating collections.

LINQ is one of the most important libraries in .NET.

LINQ makes it easy to manipulate data in different collections by minimizing the amount of code to perform a data transformation, filter the data in a collection, or compare the information contained in two collections.

With LINQ we can develop better code and follow the best practices that exist in .NET.

LINQ is essential for making Queries and developing Back End with Entity Framework.

Entity Framework allows us through classes to connect to a Database and manipulate Collections.

With LINQ we can easily perform queries and transformations on the data that will ultimately affect the database.

LINQ is also compatible with other programming languages.


-------------------------------------------------








----------    Pre requirements    ----------

- Knowledge in c#
- Knowledge in .NET
- .NET SDK 6 or higher.
- Visual Studio Code


--------------------------------------------








----------    What´s LINQ?    ----------

Surge en el 2007.

Language-Integrated Query (LINQ). It is a language that is integrated into C# and that allows us to make queries about collections.

LINQ has two ways to be implemented: "Query Expression" and "Extension Methods".

The "Extension Method" is the standard of LINQ usage until now. They are methods that appear within a collection and that allow us to perform filters and different transformations.

"Query Expression" allows us to write queries very similar to SQL queries but using C# syntax.

The namespace to use is "System.Linq". This namespace comes by default in the latest versions of .NET, for example 5 and 6.


.NET Framework is the legacy version of .NET.




 What´s not LINQ?
 
- It is not a programming language. It is only based on a programming language and extends the syntax of C#.

- Not a SQL component.

- It is not a database component. It just brings in a collection from a database and reads or transforms it. We don't need to connect to a database to use LINQ, we simply need a collection of data.

- It is not a third-party bookstore. LINQ, as it belongs to .NET, is also OpenSource.

LINQ is built into .NET. Therefore, LINQ supports all .NET-compatible languages, such as C#, Visual Basic, F#, Visual C++, etc.


LINQ example:

First way (Query Expression):
var unTomate = from t in ArraydeStrings
				where t == "Tomate"
					select t;

Second way (Extension Method):					
var unTomate = ArraydeStrings.Where(t=> t == "Tomate");


Other sources:
https://www.syncfusion.com/succinctly-free-ebooks/linq
https://learn.microsoft.com/en-us/dotnet/csharp/linq/
https://linqexamples.com/intro/
https://dotnettutorials.net/lesson/introduction-to-linq/


----------------------------------------








----------    Declarative programming vs. imperative    ----------

They are two widely used programming styles.

Modern frameworks and libraries are based on declarative programming to minimize lines of code.

LINQ supports declarative programming. This simplifies our code for handling collections.


COMPARISON

Declarative programming:
- Programming paradigm.
- Instructions where I specify what I want and not how I want it. We do not specify each step.
- Contraposition to imperative programming.
- Reliable and simple.


Imperative programming:
- Programming paradigm.
- Step-by-step instruction sequence.
- Contraposition to declarative programming.
- More extensive but easy to interpret code.

Both are programming paradigms, they are programming styles adopted by different libraries and frameworks.
They help the programmer when programming and specifying the programming style that should be followed to have best practices.

Declarative programming guides us through instructions.
We must specify what we want to do and not how we want it. It basically gives us the mechanisms through functions that are already established, so that we can define what we want to do. This could be creating an API, reading a database record, filtering a collection, or performing a query, among other actions, using a keyword, configuration file, or function. We are not going to specify each step in the code.

In imperative programming we do have to specify step by step the entire series of instructions that we want to execute to achieve a certain purpose.

Imperative programming is the classic way of programming in C#.


Other source :
https://learn.microsoft.com/es-es/dotnet/standard/linq/functional-vs-imperative-programming


------------------------------------------------------------------








----------    Using LINQ for the first time    ----------

Let's use replit:

https://replit.com/languages/csharp

https://dotnetfiddle.net/

To use LINQ we must import its library: using System.Linq;

We create a string Array.

With "StartWith("Mango")" we ask if any element starts with "Mango".

The LINQ "Where" function needs a condition that returns true or false, and depending on this it will know whether or not to filter the elements within the collection.

The one that returns true or false is the "StartWith()" function. Every time "StartWith()" returns true, "Where" will create a new collection and finally return a collection with all the elements that meet the condition.

Normally LINQ instructions return an "IEnumerable".

 
 
 
 
using System;
using System.Linq;

class Program
{
    public static void Main(string[] args)
    {
        var frutas = new string[] { "Manzana", "Pera", "Naranja", "Mango", "Mango de azucar", "Mango Tomy" };

        var MangoList = frutas.Where(p => p.StartsWith("Mango")).ToList();

        MangoList.ForEach(p => Console.WriteLine(p));

        Console.WriteLine("Fin");
    }
}





In this way we have used declarative programming. If we had used imperative programming we would have more lines of code.


In the next class we will work with a more complex project that will allow us to use several LINQ functions.
To do this we will use a Json collection that has some books loaded.


---------------------------------------------------------








----------    Creating the base project    ----------

We will configure a .NET project using a Json file that contains a collection of books that will allow us to use different functions that the LINQ library has.

We must have the .NET SDK installed.

To create this project we open the Console and go to our repository folder. We run "dotnet new console" to create a new console project. We then run "dot net run" to verify that the code is running correctly.

Finally we execute "code ." so that it opens the entire project folder in VSCode.

In the file with the ".csproj" extension we can see the configurations or characteristics of the project:


<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

The "<OutputType>Exe</OutputType>" indicates that it is an executable since it is a console project.

The "<TargetFramework>net7.0</TargetFramework>" tells us the version of the Framework.

"<ImplicitUsings>enable</ImplicitUsings>" indicates that we will not need to add "using LINQ" to use the library. We saw this in the previous course Good Practices in C#.


Now we add the Json file containing the book collection.

Json structure :

{
      "title": "Unlocking Android",
      "pageCount": 416,
      "publishedDate": "2009-04-01",
      "thumbnailUrl": "https://s3.amazonaws.com/AKIAJC5RLADLUMVRPFDQ.book-thumb-images/ableson.jpg",
      "shortDescription": "Unlocking Android: A Developer's Guide provides concise, hands-on instruction for the Android operating system and development tools. This book teaches important architectural concepts in a straightforward writing style and builds on this with practical and useful examples throughout.",
      "status": "PUBLISH",
      "authors": ["W. Frank Ableson", "Charlie Collins", "Robi Sen"],
      "categories": ["Open Source", "Mobile"]
}
    
The "thumbnailUrl" is the image of the book.

Once the Json is added to our workspace in VSCode, we go back to the "Project.csproj" configuration file to add the Json as part of the project resources.

To add it we must write the following lines of code:

<ItemGroup>
    <Content Include="books.json"/>
</ItemGroup>


Other sources:

https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-sln
https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp


-----------------------------------------------------








----------    Setting up classes    ----------

We create classes to read the Json file.

In the “Book.cs” we add each of the Json properties.

Queries are saved in "LinqQueries.cs".


----------------------------------------------








----------    Importing data    ----------

Let's transform the Json data into a Collection to start working with LINQ.



The "StreamReader" class allows us to read a file.

StreamReader reader = new StreamReader("The path where the file is located should go here.")

Since we have the file in the root of our project, we simply write the file name:

StreamReader reader = new StreamReader("books.json")


In the following code snippet we save the reading of the json file in a variable.

string json = reader.ReadToEnd();


Then we transform that file into a collection:

this.LibrosCollection = System.Text.Json.JsonSerializer.Deserialize<List<Book>>(json, new System.Text.Json.JsonSerializerOptions(){PropertyNameCaseInsensitive = true})!;

With "Deserialize<List<Book>>(json)" we are transforming the content of the Json into List<Book>.


On the other hand with "new System.Text.Json.JsonSerializerOptions(){PropertyNameCaseInsensitive = true})!" We are setting the Json properties to be in lower case, more precisely in "camelCase", while the properties of the "Book" class are in upper case.
With the "!" We establish that the data is "non-nullable."


with the following method:

public IEnumerable<Book> TodaLaColeccion()
{
        return LibrosCollection;
}

We simply return an "IEnumerable<Book>" since all we want to do is print the list elements.


In Program.cs :

Console.WriteLine("{0, -60} {1, 15} {2, 15}\n","Titulo","N. Paginas","Fecha publicacion");

This is a special functionality of "WriteLine" where using the "{}" we establish in which columns the data will be printed. It is used to control the output. It is known as a "composite format string." The numbers between {} are indexes that correspond to the arguments to be supplied after the format string. The number after the comma establishes the minimum width of the column and in turn if they are negative the texts will be aligned to the left, while if they are positive they will be aligned to the right.
In this example we are establishing three columns.


Inside the foreach :

Console.WriteLine("{0, -60} {1, 15} {2, 15}", item.Title, item.PageCount, item.PublishedDate.ToShortDateString());

With "PublishedDate.ToShortDateString()" print only the date. If we just use "PublishedDate()" in addition to printing the date, it will print the time.


--------------------------------------------








----------    Using the Where Operator    ----------

From this class we will begin to use LINQ operators.

Operators can be grouped into three categories:

- Basic Operators. Those that filter or make any specific modification to the collection.

- Aggregation Operators. They perform operations on all the data in the collection.

- Group of Operators. They group the data according to different criteria.


We start with the Basic Operators:

Where operator = Receives one or more conditions by which you can filter the collection. It works exactly the same as in SQL.



Where Operator Challenge 1: Using the Where operator returns books that were published after the year 2000.

First we will use the "Extension Method":

return LibrosCollection.Where(p=> p.PublishedDate.Year > 2000);


Then we perform the challenge with the "Query Expression":

return from l in LibrosCollection where l.PublishedDate.Year > 2000 select l;


With "select l" we are selecting each of the column elements or properties of the Book class, in this case, that we want to select.
We are selecting the entire "Book" object.


2 Operator Challenge: Using the "Where" operator returns books that are longer than 250 pages and whose title contains the words "in action."


That the “Book” properties are “nullable” will give us warnings in the queries, so this is solved in this way:

 "l.Title ?? String.Empty" 




https://learn.microsoft.com/es-mx/dotnet/csharp/linq/


----------------------------------------------------








----------    Exercise to apply the "Where" operator.    ----------

Test your new knowledge with this exercise!


using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    public static void Main(string[] args)
    {

        List<Animal> animales = new List<Animal>();
        animales.Add(new Animal() { Nombre = "Hormiga", Color = "Rojo" });
        animales.Add(new Animal() { Nombre = "Lobo", Color = "Gris" });
        animales.Add(new Animal() { Nombre = "Elefante", Color = "Gris" });
        animales.Add(new Animal() { Nombre = "Pantegra", Color = "Negro" });
        animales.Add(new Animal() { Nombre = "Gato", Color = "Negro" });
        animales.Add(new Animal() { Nombre = "Iguana", Color = "Verde" });
        animales.Add(new Animal() { Nombre = "Sapo", Color = "Verde" });
        animales.Add(new Animal() { Nombre = "Camaleon", Color = "Verde" });
        animales.Add(new Animal() { Nombre = "Gallina", Color = "Blanco" });

        // Escribe tu código aquí
        // filtra todos los animales que sean de color verde que su nombre inicie con una vocal
      
        string[] vocales = { "a", "e", "i", "o", "u" };

        foreach (var p in animales.Where(p => p.Color.Equals("verde", StringComparison.OrdinalIgnoreCase) && vocales.Any(v => p.Nombre.StartsWith(v, StringComparison.OrdinalIgnoreCase))))
        {

            Console.WriteLine(p.Nombre);

        }

        /* var searchAnimal = (from animal in animales
          where animal.Color == "Verde" && (animal.Nombre.StartsWith("A") || animal.Nombre.StartsWith("E") || animal.Nombre.StartsWith("I") || animal.Nombre.StartsWith("O") || animal.Nombre.StartsWith("U"))
            select animal);
      
        List<Animal> result = searchAnimal.ToList();

        if(result.Count > 0)
      {
        Console.WriteLine("Los animales verdes que empiezan con vocal son: ");
        foreach(var animal in result)
        {
          Console.WriteLine(animal.Nombre);
        }
      } */

        /* IEnumerable<Animal> greenAnimalsWithVowelNameStart = animales.Where(animal => animal.Color == "Verde" && "AEIOUaeiou".Contains(animal.Nombre[0])).AsEnumerable();

        if (greenAnimalsWithVowelNameStart.Any())
            foreach (var animal in greenAnimalsWithVowelNameStart)
                Console.WriteLine($"Nombre: {animal.Nombre}, Color: {animal.Color}"); */

        /* var animales1 = (from animal in animales 
                    where animal.Color == "Verde" && "AEIOUaeiou".Contains(animal.Nombre[0])
                    select animal).ToList();

        foreach (var animal in animales1)
        {
            Console.WriteLine($"Nombre: {animal.Nombre}, Color: {animal.Color}");
        } */

        /* List<char> vocales = new List<char>() { 'a', 'e', 'i', 'o', 'u' };

        List<Animal> result = animales.Where(x => x.Color.ToLower().Equals("verde") && vocales.Contains(x.Nombre.ToLower()[0])).ToList();

        if (result.Any())
          result.ForEach(x => Console.WriteLine(x.Nombre));

        foreach(var animal in result){
          Console.WriteLine(animal.Nombre);
        } */

    }
    public class Animal
    {
        public string Nombre { get; set; }
        public string Color { get; set; }
    }
}

//https://replit.com/@mathiasdesign1/LinqWhere#main.cs


----------------------------------------------------








----------    All and Any Operators    ----------

The "All" operator checks that the conditions are met on all elements in the collection.

The "Any" operator verifies that one or more conditions are met on at least one element in the collection.

Both return a boolean value that reports whether the conditions were met.


All Operator :
Using the "All" operator verify that all elements in the collection have a value in the "Status" field.


Any Operator :
Using the "Any" operator, check if any of the books were published in 2005.


-------------------------------------------------------------------








----------    Contains Operator    ----------

It informs us about the existence of an element in the collection.

It can be used for complex or primitive types.


Operator Contains :

Using the "Contains" operator, you return the elements that belong to the Python category.


---------------------------------------------